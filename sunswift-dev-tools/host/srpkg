#!/usr/bin/env python3

###############################################################################
# Sunswift High Level DDS Package generator
# Version: V3.0
# Date: 24/12/2025
# Author: Ryan Wong
#
# Creates a new package according to this structure in the directory which you
# run this script from
# 
# <package_name>/
#     .srpkg
#     src/
#     include/
#     param/
#     CMakeLists.txt
#     README.md
#
# src -> all your .cpp files
# include -> all your .hpp files
# param -> json files (probably) for static params
# 
# Usage in directory you want to create package in:
#   - srpkg create <name>
# Usage from anywhere in repository
#   - srpkg info <name>
#   - srpkg list
###############################################################################

import argparse
import sys
import re
import shutil
import json
from typing import Optional, Tuple
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass

# =================================================================================================
# CONSTANTS
# =================================================================================================

CWD = Path.cwd().resolve()
# THIS ASSUMES that repo root is 2 directories above this script...
REPO_ROOT = Path(__file__).resolve().parents[2]
if not (REPO_ROOT/"src").exists() and not (REPO_ROOT/"core").exists():
    print(f"Error: {__file__} not 2 below repo root")

# All of these are relative to pkg top level
NESTED_DIRS = {
    "src": "src",
    "include": "include",
    "param": "param",
}
FILES = {
    "metadata": ".srpkg",
    "make": "CMakeLists.txt",
    "readme": "README.md",
    "param": "param/param.json",
    "main": "src/main.cpp"
}

CLI_ARGS = {
    "create": ["name"],
    "info": ["name"],
    "list": []
}

@dataclass
class PkgPaths:
    pkg_name: str
    abs_pkg_path: Path

# =================================================================================================
# HELPERS
# =================================================================================================

def die(msg: str) -> None:
    print(msg)
    sys.exit(1)
    
def dir_size(path: Path) -> int:
    return sum(
        p.stat().st_size
        for p in path.rglob("*")
        if p.is_file()
    )

def fill_readme(paths: PkgPaths) -> None:
    text = f"""# {paths.pkg_name} DDS Package

## Description
Briefly describe the purpose of this DDS node.

## Topics Published to
Enter topics published to below
Topic | C++ Type | Description
------|----------|------------
/domain/subsystem/topic|`C++ Type`|BMS Voltage

## Topics Subscribed to
Enter topics subscribed to below
Topic | C++ Type | Description
------|----------|------------
/domain/subsystem/topic|`C++ Type`|BMS Voltage

## Parameters
Under construction!

## Contributors
Written by `Your name here` | `Your zID here`"""
    with (paths.abs_pkg_path / FILES["readme"]).open("w") as file:
        file.write(text)
        
def fill_cmakelists(paths: PkgPaths) -> None:
    text = f"""set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${{CMAKE_SOURCE_DIR}}/deploy/bin) 
add_executable({paths.pkg_name} src/main.cpp <add more source files here>)

SET (LIBS 
    dds_node
    <add your type libraries here>
    <add other dependencies here>
)

target_include_directories({paths.pkg_name} PRIVATE include)
target_link_libraries({paths.pkg_name} PRIVATE ${{LIBS}})"""
    with (paths.abs_pkg_path / FILES["make"]).open("w") as file:
        file.write(text)

# TODO: When we figure out static params
def fill_param(paths: PkgPaths) -> None:
    pass

def pkg_exist_elsewhere(paths: PkgPaths) -> tuple[bool, Optional[Path]]:
    """Recursively checks if valid package with the same name exists in src
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    Returns:
        tuple[bool, Optional[Path]]: (True/False, RELATIVE path of where it is/None)
    """
    
    src_path = REPO_ROOT / "src"
    for path in src_path.rglob(paths.pkg_name):
        if path.is_dir() and (path/FILES["metadata"]).exists():
            return (True, path.relative_to(REPO_ROOT))

    return (False, None)

def safe_rmdir(paths: PkgPaths) -> None:
    """Absolutely every error check again just to confirm before deletion. 
    In case any bugs in error checking happen before. Then deletes
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    if not paths.abs_pkg_path.exists():
        die("Delete: Path does not exist")
        
    if not paths.abs_pkg_path.is_dir():
        die("Delete: Path is not a directory")
        
    if not (paths.abs_pkg_path/FILES["metadata"]).exists():
        die("Delete: Path is not a Sunswift Package")
        
    if paths.abs_pkg_path.is_symlink():
        die("Delete: Path is a symlink")

    try:
        # Check if path is within repository 
        paths.abs_pkg_path.relative_to(REPO_ROOT)
    except ValueError:
        die("Path not within SRP8-130_EMBD_High_Level repository")
    
    if (paths.abs_pkg_path == REPO_ROOT or 
        paths.abs_pkg_path == "/" or 
        paths.abs_pkg_path == REPO_ROOT / "src"):
        die("wtf are u doing man")

    shutil.rmtree(paths.abs_pkg_path)

def validate_name(name: str) -> PkgPaths:
    ### Validate node package name
    pattern = r"^[a-z0-9_]*$"
    if not re.match(pattern, name):
        die("Invalid package name: must be in 'snake_case'")

    # Make paths objects
    abs_pkg_path = CWD / name
    paths = PkgPaths(name, abs_pkg_path)
    return paths

# =================================================================================================
# CORE LOGIC
# =================================================================================================

def parse_args() ->argparse.Namespace:
    """
    Constructs a 1 level parser with all arguments specified in CLI_ARGS above, 
    then executes and returns args
    
    You can use args.command (first level), then args.name for leaf arg
    """
    ### Command line arguments
    root_parser = argparse.ArgumentParser(
        description=f"Sunswift DDS package management tool. \
        Packages are created in your current working directory."
    )
    # at a junction, there can be many options, where one option can be another junction
    # imagine a tree structure
    level1_junction = root_parser.add_subparsers(dest="command", required=True)
    for command, arg_array in CLI_ARGS.items():
        level1_option = level1_junction.add_parser(command)
        for arg in arg_array:
            level1_option.add_argument(arg)
    
    return root_parser.parse_args()

def mkdir_package(paths: PkgPaths) -> None:
    """Actually makes the directory structure"""
    paths.abs_pkg_path.mkdir()
    for dir in NESTED_DIRS.values():
        (paths.abs_pkg_path / dir).mkdir()
    for file in FILES.values():
        (paths.abs_pkg_path / file).touch()
        if "json" in file:
            with (paths.abs_pkg_path / file).open("w") as json_file:
                json_file.write("{}")

def pkg_create(paths: PkgPaths) -> None:
    """Creates directory based on structure in top comment if it doesn't already exist.
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    # Must be created in src/
    try:
        CWD.relative_to(REPO_ROOT/"src")
    except ValueError:
        die("Error: Packages should be created only in src/")

    # Check if something with same name already exists in CWD
    if paths.abs_pkg_path.exists():
        die(f"Error: {paths.pkg_name} already exists at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")

    # Check if pkg exists elsehwhere in src/ (if not in cwd)
    res, location = pkg_exist_elsewhere(paths)
    if res:
        die(f"Error: {paths.pkg_name} already exists at '{location}'")

    # Create directories and files    
    try:
        mkdir_package(paths)
        fill_readme(paths)
        fill_cmakelists(paths)
        fill_param(paths)
    except Exception as e:
        if paths.abs_pkg_path.exists():
            safe_rmdir(paths)
        die(f"Error creating package: {e}")

    print(f"✅ Package '{paths.pkg_name}' created successfully!")
    print(f"Location: {paths.abs_pkg_path.relative_to(REPO_ROOT)}\n")

    # Determine padding for nice alignment
    all_names = list(NESTED_DIRS.values()) + list(FILES.values())
    max_len = max(len(name) for name in all_names) + 2

    print("Created structure:")
    # Directories
    for dir in NESTED_DIRS.values():
        dir_path = paths.abs_pkg_path / dir
        exists = "✔" if dir_path.exists() else "✖"
        print(f"  {dir.ljust(max_len)}: {exists}")
    # Files
    for file_name in FILES.values():
        file_path = paths.abs_pkg_path / file_name
        exists = "✔" if file_path.exists() else "✖"
        print(f"  {file_name.ljust(max_len)}: {exists}")

def pkg_info(paths: PkgPaths) -> None:
    """ Finds package with given name in repository
    Args:
        paths (PkgPaths): _description_
    """
    res, location = pkg_exist_elsewhere(paths)

    if not res or location is None:
        die(f"Package: '{paths.pkg_name}' not found in src/")
        return # pydantic shut up

    print(f"=============== {paths.pkg_name} INFO ===============")
    # get size and num things
    abs_path = REPO_ROOT / location
    size_bytes = dir_size(abs_path)
    size_kb = size_bytes / 1024
    num_files = sum(1 for thing in abs_path.rglob("*") if thing.is_file())
    num_dirs = sum(1 for thing in abs_path.rglob("*") if thing.is_dir())

    # Get last modified + creation times
    all_files = list(abs_path.rglob("*"))
    if all_files:
        creation_ts = min(p.stat().st_ctime for p in all_files)
        last_mod_ts = max(p.stat().st_mtime for p in all_files)
    else:
        creation_ts = last_mod_ts = abs_path.stat().st_ctime

    creation_date = datetime.fromtimestamp(creation_ts).strftime("%d/%m/%Y %H:%M:%S")
    last_mod_date = datetime.fromtimestamp(last_mod_ts).strftime("%d/%m/%Y %H:%M:%S")

    # Combine all names to compute max padding
    all_names = list(NESTED_DIRS.values()) + list(FILES.values())
    max_len = max(len(name) for name in all_names) + 2 

    print(f"Package: '{paths.pkg_name}'")
    print(f"Location: {location}")
    print(f"Total size: {size_bytes} B ({size_kb:.2f} KB)")
    print(f"Contents: {num_dirs} directories, {num_files} files")
    print(f"Created: {creation_date}")
    print(f"Last modified: {last_mod_date}")
    
    # List source files
    src_dir = abs_path / "src"
    if src_dir.exists():
        cpp_files = sorted([f.relative_to(abs_path) for f in src_dir.rglob("*.cpp")])
        if cpp_files:
            print("\nSource files (.cpp):")
            for f in cpp_files:
                print(f"  {f}")

    # List header files
    include_dir = abs_path / "include"
    if include_dir.exists():
        hpp_files = sorted([f.relative_to(abs_path) for f in include_dir.rglob("*.hpp")])
        if hpp_files:
            print("\nHeader files (.hpp):")
            for f in hpp_files:
                print(f"  {f}")

def pkg_list() -> None:
    """Lists all valid DDS packages under src/. Valid means contains FILES["metadata"]"""
    src_root = REPO_ROOT / "src"
    if not src_root.exists():
        die("No src/ directory found in repository.")

    print(f"=============== NODE LIST ===============")
    packages = []

    # recursively search
    for path in src_root.rglob("*"):
        if path.is_dir() and (path / FILES["metadata"]).exists():
            pkg_name = path.name
            rel_path = path.relative_to(REPO_ROOT)
            packages.append((pkg_name, rel_path))

    if not packages:
        print("No packages found in src/")
        return

    # sort by name for neatness (already sorts using first tuple element)
    # packages.sort()

    # Determine padding for alignment
    max_name_len = max(len(name) for name, _ in packages) + 2

    print(f"Found {len(packages)} package(s) in src/:\n")
    for name, rel_path in packages:
        print(f"  {name.ljust(max_name_len)} : {rel_path}")


# =================================================================================================
# MAIN
# =================================================================================================
def main():
    args = parse_args()

    ### SANITY CHECK:
    # Wheck that script is run in repo
    try:
        CWD.relative_to(REPO_ROOT)
    except ValueError:
        die("Error: Script must be run within repository")

    ### LOGIC BASED ON FLAGS
    cmd = args.command
    if cmd == "create":
        paths = validate_name(args.name)
        pkg_create(paths)
    elif cmd == "info":
        paths = validate_name(args.name)
        pkg_info(paths)
    elif cmd == "list":
        pkg_list()


if __name__ == "__main__":
    main()