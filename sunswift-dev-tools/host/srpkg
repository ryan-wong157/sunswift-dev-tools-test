#!/usr/bin/env python3

###############################################################################
# Sunswift High Level DDS Package generator
# Version: V1.0
# Date: 24/12/2025
# Author: Ryan Wong
#
# Creates a new package according to this structure in the directory which you
# run this script from
# 
# <package_name>/
#     pkg_metadata.json
#     build/
#     src/
#     include/
#     config/
#     launch/
#     CMakeLists.txt
#     README.md
#
# build -> for CMakeLists.txt to put artifacts and final binary
# src -> all your .cpp files
# include -> all your .hpp files
# config -> json files (probably) for node configs + static params
# launch -> containing one or more launch files
# 
# Usage in directory you want to create pkg in:
#   
###############################################################################

import argparse
import sys
import re
import shutil
import json
from typing import Optional, Tuple
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass

CWD = Path.cwd()
# THIS ASSUMES that repo root is 2 directories above this script...
REPO_ROOT = Path(__file__).resolve().parents[2]

@dataclass
class PkgPaths:
    pkg_name: str
    abs_pkg_path: Path

### HELPERS =====================================================================================

def die(msg: str) -> None:
    print(msg)
    sys.exit(1)
    
def dir_size(paths: PkgPaths) -> int:
    path = paths.abs_pkg_path
    return sum(
        p.stat().st_size
        for p in path.rglob("*")
        if p.is_file()
    )

def fill_readme(path: Path) -> bool:
    pass

def fill_cmakelists(path: Path) -> bool:
    pass

def fill_launch(path: Path) -> bool:
    pass

def fill_config(path: Path) -> bool:
    pass

def fill_metadata(path: Path) -> bool:
    pass

def pkg_exist_elsewhere(paths: PkgPaths) -> tuple[bool, Optional[Path]]:
    """Recursively checks if valid package with the same name exists in the whole repository
=    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    Returns:
        tuple[bool, Optional[Path]]: (True/False, RELATIVE path of where it is/None)
    """
    if paths.abs_pkg_path.exists():
        return (True, paths.abs_pkg_path)
    
    src_path = REPO_ROOT
    for path in src_path.rglob(paths.pkg_name):
        if path.is_dir() and (path/"pkg_metadata.json").exists():
            return (True, path.relative_to(REPO_ROOT))

    return (False, None)

def safe_rmdir(paths: PkgPaths) -> None:
    """Absolutely every error check again just to confirm before deletion. 
    In case any bugs in error checking happen before. Then deletes
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    if not paths.abs_pkg_path.exists():
        die("Delete: Path does not exist")
        
    if not paths.abs_pkg_path.is_dir():
        die("Delete: Path is not a directory")
        
    if not (paths.abs_pkg_path/"pkg_metadata.json").exists():
        die("Delete: Path is not a Sunswift Package")
    
    try:
        # Check if path is within repository 
        paths.abs_pkg_path.relative_to(REPO_ROOT)
    except ValueError:
        die("Path not within SRP8-130_EMBD_High_Level repository")
    
    if paths.abs_pkg_path == REPO_ROOT or paths.abs_pkg_path == "/":
        die("wtf are u doing man")
        
    shutil.rmtree(paths.abs_pkg_path)

### CORE LOGIC ==================================================================================

def pkg_create(paths: PkgPaths) -> None:
    """Creates directory based on structure in top comment if it doesn't already exist.
        
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    nested_dirs = ["build", "src", "include", "config", "launch"]
    files = ["pkg_metadata.json", "CMakeLists.txt", "README.md"]
    
    # Check if something with same name already exists in CWD
    if paths.abs_pkg_path.exists():
        die(f"Package: {paths.pkg_name} already exists at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")

    # Check if pkg exists elsehwhere in src/ (if not in cwd)
    res, location = pkg_exist_elsewhere(paths)
    if res and (location is not None):
        die(f"Package: {paths.pkg_name} already exists at '{location}'")
    
    # Create directories and files    
    try:
        for dir in nested_dirs:
            (paths.abs_pkg_path / dir).mkdir(parents=True)
        for file in files:
            (paths.abs_pkg_path / file).touch()
        
        # TODO: Populate CMakeLists.txt, README.md and create launch and config templates
    except Exception as e:
        ### TODO: ROLLBACK THE DIRECTORY CREATION IF FAILS
        die(f"Error creating package: {e}")

    print("Package: create success")
    print(f"Package: '{paths.pkg_name}' created at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")


def pkg_delete(paths: PkgPaths) -> None:
    """Deletes directory with paths.pkg_name if it's in the cwd, and it's a Sunswift DDS pkg
     
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """     
    # Check if pkg exists in CWD and is a valid DDS package
    if not (paths.abs_pkg_path.exists() and paths.abs_pkg_path.is_dir() and (paths.abs_pkg_path/"pkg_metadata.json").exists()):
        print(f"Package: '{paths.pkg_name}' cannot be found in current directory")
        print(f"Searching for package in repository...")
        print("-----")
        res, location = pkg_exist_elsewhere(paths)
        if res and (location is not None):
            die(f"Package: '{paths.pkg_name}' found at '{location}'. Please navigate here to delete")
        else:
            die("Package not found in repository")


    stats = paths.abs_pkg_path.stat()
    print(f"Found Sunswift DDS package: '{paths.pkg_name}' at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")
    print(f"Package size (bytes): {dir_size(paths)}")
    print(f"Created: {datetime.fromtimestamp(stats.st_ctime).strftime("%Y-%m-%d %H:%M:%S")}")
    res = input(f"Do you really want to delete '{paths.pkg_name}' (y/n): ")
    print("-----")
    if res.lower() == "y":
        safe_rmdir(paths)
        
        print(f"Package: '{paths.pkg_name}' successfully deleted")
    else:
        print("Stopping delete...")
        sys.exit(0)
         
                
    
### MAIN =======================================================================================
def main():
    ### Command line arguments
    parser = argparse.ArgumentParser(
            description="Sunswift DDS package management tool. \
            To create and delete packages, you must be in the same directory as the package"
        )
    group = parser.add_mutually_exclusive_group(required=True)

    parser.add_argument("pkg_name", help="Name of package to be created/deleted")
    group.add_argument("-c", "--create", action="store_true", help="Create specified package")
    group.add_argument("-d", "--delete", action="store_true", help="Remove specified package")
    group.add_argument("-f", "--find", action="store_true", help="Find specified package")
    args = parser.parse_args()
        
    pkg_name = args.pkg_name
    
    ### Validate package name
    pattern = r"^[a-z0-9_]*$"
    if not re.match(pattern, pkg_name):
        die("Invalid package name: must be in 'snake_case'")
    
    # Make paths objects
    abs_pkg_path = CWD / pkg_name
    paths = PkgPaths(pkg_name, abs_pkg_path)

    ### SANITY CHECK:
    # Wheck that script is run in repo
    try:
        CWD.relative_to(REPO_ROOT)
    except ValueError:
        die("Error: Script must be run within repository")
    # Warn if not used in src/
    try:
        CWD.relative_to(REPO_ROOT/"src")
    except ValueError:
        args.create and print("Warning: Packages should be created only in src/")
    
    ### Logic based on flags
    if args.create:
        pkg_create(paths)
    elif args.delete:
        pkg_delete(paths)
    # TODO: find and mv flags

if __name__ == "__main__":
    main()