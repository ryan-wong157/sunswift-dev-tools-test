#!/usr/bin/env python3

###############################################################################
# Sunswift High Level DDS Package generator
# Version: V2.0
# Date: 24/12/2025
# Author: Ryan Wong
#
# Creates a new package according to this structure in the directory which you
# run this script from
# 
# <package_name>/
#     srpkg.json
#     src/
#     include/
#     param/
#     CMakeLists.txt
#     README.md
#
# src -> all your .cpp files
# include -> all your .hpp files
# param -> json files (probably) for static params
# 
# Usage in directory you want to create pkg in:
#   - srpkg node create bro
#   - srpkg node info bro
#   - srpkg node list
#   - srpkg type create bro_type
#   - srpkg type info bro_type
#   - srpkg type list
###############################################################################

import argparse
import sys
import re
import shutil
import json
from typing import Optional, Tuple
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass

# =================================================================================================
# CONSTANTS
# =================================================================================================

CWD = Path.cwd().resolve()
# THIS ASSUMES that repo root is 2 directories above this script...
REPO_ROOT = Path(__file__).resolve().parents[2]
if not (REPO_ROOT/"src").exists() and not (REPO_ROOT/"core").exists():
    print(f"Error: {__file__} not 2 below repo root")

# All of these are relative to pkg top level
NESTED_DIRS = {
    "src": "src",
    "include": "include",
    "param": "param",
}
FILES = {
    "metadata": "srpkg.json",
    "make": "CMakeLists.txt",
    "readme": "README.md",
    "param": "param/param.json",
}

CLI_ARGS = {
    "node": {
        "create": ["name"],
        "info": ["name"],
        "list": []
    },
    "type": {
        "create": ["name"],
        "info": ["name"],
        "list": []
    }
}

@dataclass
class PkgPaths:
    pkg_name: str
    abs_pkg_path: Path

# =================================================================================================
# HELPERS
# =================================================================================================

def die(msg: str) -> None:
    print(msg)
    sys.exit(1)
    
# def dir_size(paths: PkgPaths) -> int:
#     path = paths.abs_pkg_path
#     return sum(
#         p.stat().st_size
#         for p in path.rglob("*")
#         if p.is_file()
#     )

def mkdir_package(paths: PkgPaths) -> None:
    paths.abs_pkg_path.mkdir()
    for dir in NESTED_DIRS.values():
        (paths.abs_pkg_path / dir).mkdir()
    for file in FILES.values():
        (paths.abs_pkg_path / file).touch()
        if "json" in file:
            with (paths.abs_pkg_path / file).open("w") as json_file:
                json_file.write("{}")

def fill_readme(paths: PkgPaths) -> None:
    text = f"""# {paths.pkg_name} DDS Package

## Description
Briefly describe the purpose of this DDS node.

## Topics Published to
Enter topics published to below
Topic | C++ Type | Description
------|----------|------------
/domain/subsystem/topic|`C++ Type`|BMS Voltage

## Topics Subscribed to
Enter topics subscribed to below
Topic | C++ Type | Description
------|----------|------------
/domain/subsystem/topic|`C++ Type`|BMS Voltage

## Parameters
Under construction!

## Contributors
Written by `Your name here` | `Your zID here`"""
    with (paths.abs_pkg_path / FILES["readme"]).open("w") as file:
        file.write(text)
        
# TODO: implement these when i figure out what goes in them
def fill_cmakelists(path: Path) -> None:
    pass

def fill_param(path: Path) -> None:
    pass

def fill_metadata(paths: PkgPaths) -> None:
    abs_meta_path = paths.abs_pkg_path / FILES["metadata"]
    data = json.loads(abs_meta_path.read_text())
    data["kind"] = "node"
    # Make it look readable
    abs_meta_path.write_text(json.dumps(data, indent=2) + "\n")

def pkg_exist_elsewhere(paths: PkgPaths) -> tuple[bool, Optional[Path]]:
    """Recursively checks if valid package with the same name exists in src
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    Returns:
        tuple[bool, Optional[Path]]: (True/False, RELATIVE path of where it is/None)
    """
    
    src_path = REPO_ROOT / "src"
    for path in src_path.rglob(paths.pkg_name):
        if path.is_dir() and (path/FILES["metadata"]).exists():
            return (True, path.relative_to(REPO_ROOT))

    return (False, None)

def safe_rmdir(paths: PkgPaths) -> None:
    """Absolutely every error check again just to confirm before deletion. 
    In case any bugs in error checking happen before. Then deletes
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    if not paths.abs_pkg_path.exists():
        die("Delete: Path does not exist")
        
    if not paths.abs_pkg_path.is_dir():
        die("Delete: Path is not a directory")
        
    if not (paths.abs_pkg_path/"pkg_metadata.json").exists():
        die("Delete: Path is not a Sunswift Package")
        
    if paths.abs_pkg_path.is_symlink():
        die("Delete: Path is a symlink")

    try:
        # Check if path is within repository 
        paths.abs_pkg_path.relative_to(REPO_ROOT)
    except ValueError:
        die("Path not within SRP8-130_EMBD_High_Level repository")
    
    if (paths.abs_pkg_path == REPO_ROOT or 
        paths.abs_pkg_path == "/" or 
        paths.abs_pkg_path == REPO_ROOT / "src"):
        die("wtf are u doing man")

    shutil.rmtree(paths.abs_pkg_path)

def validate_name(name: str) -> PkgPaths:
    ### Validate node/type package name
    pattern = r"^[a-z0-9_]*$"
    if not re.match(pattern, name):
        die("Invalid package name: must be in 'snake_case'")

    # Make paths objects
    abs_pkg_path = CWD / name
    paths = PkgPaths(name, abs_pkg_path)
    return paths

# =================================================================================================
# CORE LOGIC
# =================================================================================================

def parse_args() ->argparse.Namespace:
    """
    Constructs a 2 level parser with all arguments specified in CLI_ARGS above, 
    then executes and returns args
    
    You can use args.object (first level), args.obj_command (second level), then args.name for leaf arg
    """
    ### Command line arguments
    root_parser = argparse.ArgumentParser(
        description=f"Sunswift DDS package management tool. \
        Packages are created in your current working directory."
    )
    # at a junction, there can be many options, where one option can be another junction
    # imagine a tree structure
    level1_junction = root_parser.add_subparsers(dest="object", required=True)
    for obj_name, action_dict in CLI_ARGS.items():
        level1_option = level1_junction.add_parser(obj_name)
        level2_junction = level1_option.add_subparsers(dest=f"{obj_name}_command", required=True)
        for action, args in action_dict.items():
            level2_option = level2_junction.add_parser(action)
            for arg in args:
                level2_option.add_argument(arg)
    
    return root_parser.parse_args()

def pkg_create(paths: PkgPaths) -> None:
    """Creates directory based on structure in top comment if it doesn't already exist.
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    # Check if something with same name already exists in CWD
    if paths.abs_pkg_path.exists():
        die(f"Error: {paths.pkg_name} already exists at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")

    # Check if pkg exists elsehwhere in src/ (if not in cwd)
    res, location = pkg_exist_elsewhere(paths)
    if res:
        die(f"Error: {paths.pkg_name} already exists at '{location}'")

    # Create directories and files    
    try:
        mkdir_package(paths)
        # TODO: Populate CMakeLists.txt, and launch and config templates
        fill_readme(paths)
        fill_metadata(paths)
    except Exception as e:
        if paths.abs_pkg_path.exists():
            safe_rmdir(paths)
        die(f"Error creating package: {e}")

    print("Success: Package creation success")
    print(f"Package: '{paths.pkg_name}' created at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")

def pkg_info(paths: PkgPaths) -> None:
    """ Finds package with given name in repository
    Args:
        paths (PkgPaths): _description_
    """
    res, location = pkg_exist_elsewhere(paths)
    if res and (location is not None):
        print(f"Package: '{paths.pkg_name}' found at '{location}'")
    else:
        print(f"Package: '{paths.pkg_name}' not found in repository")


# =================================================================================================
# MAIN
# =================================================================================================
def main():
    args = parse_args()

    ### SANITY CHECK:
    # Wheck that script is run in repo
    try:
        CWD.relative_to(REPO_ROOT)
    except ValueError:
        die("Error: Script must be run within repository")
    
    # Must be created in src/ if node and core/dds_types if type
    if args.object == "node" and args.node_command == "create":
        try:
            CWD.relative_to(REPO_ROOT/"src")
        except ValueError:
            die("Error: Node packages should be created only in src/")
    elif args.object == "type" and args.type_command == "create":
        try:
            CWD.relative_to(REPO_ROOT/"core/dds_types")
        except ValueError:
            die("Error: Type packages should be created only in core/dds_types/")

    ### LOGIC BASED ON FLAGS
    if args.object == "node":
        cmd = args.node_command
        if cmd == "create":
            paths = validate_name(args.name)
            pkg_create(paths)
        elif cmd == "info":
            paths = validate_name(args.name)
            pkg_info(paths)
        elif cmd == "list":
            # list_nodes()
            pass
    elif args.object == "type":
        cmd = args.type_command
        if cmd == "create":
            paths = validate_name(args.name)
            # create_type(paths)
        elif cmd == "info":
            paths = validate_name(args.name)
            # pkg_info(paths)
        elif cmd == "list":
            # list_types()
            pass


if __name__ == "__main__":
    main()