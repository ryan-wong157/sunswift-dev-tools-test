#!/usr/bin/env python3

###############################################################################
# Sunswift High Level DDS Package generator
# Version: V2.0
# Date: 24/12/2025
# Author: Ryan Wong
#
# Creates a new package according to this structure in the directory which you
# run this script from
# 
# <package_name>/
#     pkg_metadata.json
#     src/
#     include/
#     config/
#     launch/
#     CMakeLists.txt
#     README.md
#
# src -> all your .cpp files
# include -> all your .hpp files
# config -> json files (probably) for node configs + static params
# launch -> containing one or more launch files
# 
# Usage in directory you want to create pkg in:
#   
###############################################################################

import argparse
import sys
import re
import shutil
import json
from typing import Optional, Tuple
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass

CWD = Path.cwd()
# THIS ASSUMES that repo root is 2 directories above this script...
REPO_ROOT = Path(__file__).resolve().parents[2]
if not (REPO_ROOT/"src").exists() and not (REPO_ROOT/"core").exists():
    print(f"Error: {__file__} not 2 below repo root")

# All of these are relative to pkg top level
nested_dirs = {
    "src": "src",
    "include": "include",
    "config": "config",
    "launch": "launch"
}
files = {
    "metadata": "pkg_metadata.json",
    "make": "CMakeLists.txt",
    "readme": "README.md",
    "config": "config/config.json",
    "launch": "launch/launch.json"
}

@dataclass
class PkgPaths:
    pkg_name: str
    abs_pkg_path: Path

### HELPERS =======================================================================================

def die(msg: str) -> None:
    print(msg)
    sys.exit(1)
    
def dir_size(paths: PkgPaths) -> int:
    path = paths.abs_pkg_path
    return sum(
        p.stat().st_size
        for p in path.rglob("*")
        if p.is_file()
    )

def mkdir_package(paths: PkgPaths) -> None:
    paths.abs_pkg_path.mkdir()
    for dir in nested_dirs.values():
        (paths.abs_pkg_path / dir).mkdir()
    for file in files.values():
        (paths.abs_pkg_path / file).touch()
        if "json" in file:
            with (paths.abs_pkg_path / file).open("w") as json_file:
                json_file.write("{}")

def fill_readme(paths: PkgPaths) -> None:
    text = f"""# {paths.pkg_name} DDS Package

## Description
Briefly describe the purpose of this DDS node.

## Topics Published to
Enter topics published to below
Topic | C++ Type | Description
------|----------|------------
/domain/subsystem/topic|`C++ Type`|BMS Voltage

## Topics Subscribed to
Enter topics subscribed to below
Topic | C++ Type | Description
------|----------|------------
/domain/subsystem/topic|`C++ Type`|BMS Voltage

## Parameters
Under construction!

## Acknowledgements
Written by `Your name here` | `Your zID here`"""
    with (paths.abs_pkg_path / "README.md").open("w") as file:
        file.write(text)
        
# TODO: implement these when i figure out what goes in them
def fill_cmakelists(path: Path) -> None:
    pass

def fill_launch(path: Path) -> None:
    pass

def fill_config(path: Path) -> None:
    pass

def fill_metadata(paths: PkgPaths) -> None:
    abs_meta_path = paths.abs_pkg_path / files["metadata"]
    data = json.loads(abs_meta_path.read_text())
    data["version"] = 1
    data["package_name"] = paths.pkg_name
    data["package_type"] = "dds_node" # for now i guess
    data["target"] = "qnx"
    data["default_launch"] = files["launch"]
    data["default_config"] = files["config"]
    # Make it look readable
    abs_meta_path.write_text(json.dumps(data, indent=2) + "\n")

def pkg_exist_elsewhere(paths: PkgPaths) -> tuple[bool, Optional[Path]]:
    """Recursively checks if valid package with the same name exists in the whole repository
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    Returns:
        tuple[bool, Optional[Path]]: (True/False, RELATIVE path of where it is/None)
    """
    
    src_path = REPO_ROOT
    for path in src_path.rglob(paths.pkg_name):
        if path.is_dir() and (path/"pkg_metadata.json").exists():
            return (True, path.relative_to(REPO_ROOT))

    return (False, None)

def safe_rmdir(paths: PkgPaths) -> None:
    """Absolutely every error check again just to confirm before deletion. 
    In case any bugs in error checking happen before. Then deletes
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    if not paths.abs_pkg_path.exists():
        die("Delete: Path does not exist")
        
    if not paths.abs_pkg_path.is_dir():
        die("Delete: Path is not a directory")
        
    if not (paths.abs_pkg_path/"pkg_metadata.json").exists():
        die("Delete: Path is not a Sunswift Package")
        
    if paths.abs_pkg_path.is_symlink():
        die("Delete: Path is a symlink")

    try:
        # Check if path is within repository 
        paths.abs_pkg_path.relative_to(REPO_ROOT)
    except ValueError:
        die("Path not within SRP8-130_EMBD_High_Level repository")
    
    if paths.abs_pkg_path == REPO_ROOT or paths.abs_pkg_path == "/" or paths.abs_pkg_path == REPO_ROOT / "src":
        die("wtf are u doing man")

    shutil.rmtree(paths.abs_pkg_path)


### CORE LOGIC ====================================================================================

def pkg_create(paths: PkgPaths) -> None:
    """Creates directory based on structure in top comment if it doesn't already exist.
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """
    # Check if something with same name already exists in CWD
    if paths.abs_pkg_path.exists():
        die(f"Package: {paths.pkg_name} already exists at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")

    # Check if pkg exists elsehwhere in src/ (if not in cwd)
    res, location = pkg_exist_elsewhere(paths)
    if res:
        die(f"Package: {paths.pkg_name} already exists at '{location}'")

    # Create directories and files    
    try:
        mkdir_package(paths)
        # TODO: Populate CMakeLists.txt, and launch and config templates
        fill_readme(paths)
        fill_metadata(paths)
    except Exception as e:
        if paths.abs_pkg_path.exists():
            safe_rmdir(paths)
        die(f"Error creating package: {e}")

    print("Package: create success")
    print(f"Package: '{paths.pkg_name}' created at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")

def pkg_delete(paths: PkgPaths) -> None:
    """Deletes directory with paths.pkg_name if it's in the cwd, and it's a Sunswift DDS pkg
    Args:
        paths (PkgPaths): dataclass which stores name and abs path of pkg
    """     
    # Check if pkg exists in CWD and is a valid DDS package
    if not (paths.abs_pkg_path.exists() and paths.abs_pkg_path.is_dir() and (paths.abs_pkg_path/"pkg_metadata.json").exists()):
        print(f"Package: '{paths.pkg_name}' cannot be found in current directory")
        print(f"Searching for package in repository...")
        print("-----")
        res, location = pkg_exist_elsewhere(paths)
        if res and (location is not None):
            die(f"Package: '{paths.pkg_name}' found at '{location}'. Please navigate here to delete")
        else:
            die("Package not found in repository\nYou may be trying to delete a directory which isn't a valid Sunswift Package")

    stats = paths.abs_pkg_path.stat()
    print(f"Found Sunswift DDS package: '{paths.pkg_name}' at '{paths.abs_pkg_path.relative_to(REPO_ROOT)}'")
    print(f"Package size (bytes): {dir_size(paths)}")
    print(f"Created: {datetime.fromtimestamp(stats.st_ctime).strftime("%Y-%m-%d %H:%M:%S")}")
    res = input(f"Do you really want to delete '{paths.pkg_name}' (y/n): ")
    print("-----")
    if res.lower() == "y":
        safe_rmdir(paths)
        print(f"Package: '{paths.pkg_name}' successfully deleted")
    else:
        print("Stopping delete...")
        sys.exit(0)

def pkg_find(paths: PkgPaths) -> None:
    """ Finds package with given name in repository
    Args:
        paths (PkgPaths): _description_
    """
    res, location = pkg_exist_elsewhere(paths)
    if res and (location is not None):
        print(f"Package: '{paths.pkg_name}' found at '{location}'")
    else:
        print(f"Package: '{paths.pkg_name}' not found in repository")

def pkg_rename(paths: PkgPaths, new_name: str) -> None:
    if paths.pkg_name == new_name:
        die("Error: Name is the same")

    # Check if pkg exists in CWD and is a valid DDS package
    if not (paths.abs_pkg_path.exists() and paths.abs_pkg_path.is_dir() and (paths.abs_pkg_path/"pkg_metadata.json").exists()):
        print(f"Package: '{paths.pkg_name}' cannot be found in current directory")
        print(f"Searching for package in repository...")
        print("-----")
        res, location = pkg_exist_elsewhere(paths)
        if res and (location is not None):
            die(f"Package: '{paths.pkg_name}' found at '{location}'. Please navigate here to rename")
        die(f"Package: '{paths.pkg_name}' not found")

    res = input(f"Do you want to rename '{paths.pkg_name}' to '{new_name}'? (y/n): ")
    if res.lower() == "y":
        # Handle Pylance possible unbound variable  
        abs_new_metadata = None
        try:
            # Update metadata file in atomic way
            abs_old_metadata = (paths.abs_pkg_path / files["metadata"])
            abs_new_metadata = (paths.abs_pkg_path / ("new_" + files["metadata"]))
            
            data = json.loads(abs_old_metadata.read_text())
            data["package_name"] = new_name
            abs_new_metadata.write_text(json.dumps(data, indent=2) + "\n")
            abs_new_metadata.replace(abs_old_metadata)
            
            # Update package name
            paths.abs_pkg_path.rename(paths.abs_pkg_path.parent / new_name)
        except Exception as e:
            if abs_new_metadata is not None:       
                if abs_new_metadata.exists():
                    abs_new_metadata.unlink()
            die(f"Failed to update metadata: {e}")
    else:
        die("Stopping rename...")
    
    print(f"Successfully renamed '{paths.pkg_name}' to '{new_name}'")


### MAIN ==========================================================================================
def main():
    ### Command line arguments
    parser = argparse.ArgumentParser(
            description=f"Sunswift DDS package management tool. \
            To create, delete and rename packages, you must be in the same directory as the package."
        )
    group = parser.add_mutually_exclusive_group(required=True)

    parser.add_argument("pkg_name", help="Name of package to be created/deleted/found/renamed")
    group.add_argument("-c", "--create", action="store_true", help="Create specified package")
    group.add_argument("-d", "--delete", action="store_true", help="Remove specified package")
    group.add_argument("-f", "--find", action="store_true", help="Find specified package")
    group.add_argument("-r", "--rename", metavar="new_name", help="Rename specified package")
    args = parser.parse_args()

    pkg_name = args.pkg_name

    ### Validate package name
    pattern = r"^[a-z0-9_]*$"
    if not re.match(pattern, pkg_name):
        die("Invalid package name: must be in 'snake_case'")

    # Make paths objects
    abs_pkg_path = CWD / pkg_name
    paths = PkgPaths(pkg_name, abs_pkg_path)

    ### SANITY CHECK:
    # Wheck that script is run in repo
    try:
        CWD.relative_to(REPO_ROOT)
    except ValueError:
        die("Error: Script must be run within repository")
    # Warn if not used in src/
    try:
        CWD.relative_to(REPO_ROOT/"src")
    except ValueError:
        # This very bash-like line is a testament to the old pkg_creat.sh :(
        args.create and print("Warning: Packages should be created only in src/")

    ### Logic based on flags
    if args.create:
        pkg_create(paths)
    elif args.delete:
        pkg_delete(paths)
    elif args.find:
        pkg_find(paths)
    elif args.rename:
        pkg_rename(paths, args.rename)

if __name__ == "__main__":
    main()